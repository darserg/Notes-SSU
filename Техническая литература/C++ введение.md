
## C++ Введение
#### Автор - Дарьин Сергей, студент 131 группы факультета Компьютерных Наук и Информационных Технологий, компьютерная безопасность, 2024

```cpp
#include <iostream>

int main() {
	std::cout << "Hello, World!";
	return 0;
}
```
Для тех, кто только начинает программировать, C++ кажется очень сложным языком, ведь здесь нужно внимательно следить за очишением памяти, за фигурными скобками и т.д. 
После Python изучение любого языка программирования кажется очень трудным, ведь в python программы выглядят, как англоязычная речь, а тут сразу много страшных и непонятных символов.


### Глава 1. Hello, World!
На самом деле, C++ - вовсе не такой сложный, каким кажется, но его нужно понять
Разберём простейший пример - вывод стандартной фразы "Hello, World!" В консоль:

```cpp
#include <iostream>

int main() {
	std::cout << "Hello, World!";
	return 0;
}
```

Функция выглядит громоздко, но давайте разберём каждую строку
```cpp
#include <iostream>
```
Команда \#include используется для подключения любой библиотеки (библиотека - это код, написанный другими разработчиками, который предназначен для решения каких-нибудь рутинных задач, таких, как вывод в консоль)
Библиотека же \<iostream> - одна из встроенных библиотек в языке C++, предназначенная для вывода информации на консоль или ввода текста с консоли

Не так уж и сложно, правда?
Поехали дальше
```cpp
int main() {
	// any code here
}
```

#### Что ещё за int main? Почему там так много скобочек?
Начнём по порядку.
int - базовый тип данных, предназначенный для хранения целых чисел, но в данный момент этот код не хранит никакие чисел. 
int main - стандартная функция, которая является точкой входа в программу, с неё начинается выполнение любого другого действия. В других языках, похожих на C++ main - не int, а void - метод

##### А что есть функция? И причём здесь метод?
Функция - фрагмент кода, который возвращает какое-либо значение, например, функция может возводить число в квадрат
Метод - фрагмент кода, который не возвращает никаких значений

Круглые скобки нужны для обозначения каких-нибудь данных, которые мы передаём в функцию для примера давайте рассмотрим функцию возведения числа в квадрат

```cpp
int square(int n) {
	return n * n;
}
```

В фигурных скобочках появилось новая переменная -  n, которая может быть любым целым числом.
return - в переводе с английского возвращать - ключевое слово, предназначенное для того, чтобы возвращать какое-либо значение из функции.

Но вернёмся к функции main
```cpp
#include <iostream>

int main() {
	std::cout << "Hello, World!";
	return 0;
}
```
Появилась новая страшная строка \std::cout << "Hello, World!"; 
Разберёмся, что она делает:
std - standart template definition - там находятся все стандартные инструменты языка C++
:: - синтаксис вывода инструмента из библиотеки
cout - стандартная функция вывода в консоль (console output)
<< - оператор сдвига вправо разберёмся с этим позднее, когда будем проходить математические действия
 "Hello, World!" - строка, которая будет выводиться в консоль

Скорее всего, вы обратили внимание, что в конце каждой строки стоит точка с запятой. Это необходимо, чтобы компилятор понимал, где заканчивается строка. 

Даввйте рассмотрим пример посложнее.
##### Ввод/вывод данных в консоли
```cpp
#include <iostream>

int main() {
	int age;
	std::cout << "How old are you? ";
	std::cin >> age;
	return 0;
}
```
Эта программа создаёт переменную (см. Глава 2), потом выводит на консоль вопрос "Сколько тебе лет", после получает данные из консоли (одно число)

### Глава 2.  Переменные и типы данных

Что такое переменная? 
Переменная - некий контейнер, в котором хранится значение (значение переменной можно изменить). Этим значением может быть всё, что угодно, может быть число, может быть слово, а может - даже целое предложение. Для того, чтобы разобраться, как создать переменную, сначала нужно разобраться с типами данных 

##### Целочисленные типы
int - целочисленная переменная, которая занимает 4 байта памяти и может хранить положительное или отрицательное значение (предел значений - от -2147483648 до 2147483647, предел значения типа данных можно не запоминать, всегда можно проверить через C++)

bool - логическая переменная, которая занимает 1 байт памяти и может хранить два значения - true или false - истина / ложь

short - целочисленная переменная, которая занимает 2 байта памяти и может хранить положительное или отрицательное число (предел значений - от -32768 до 32767)

long - целочисленная переменная, которая занимает от 4 до 8 байт памяти (зависит от архитектуры компьютера) (предел значений - −2 147 483 648 до 2 147 483 647 (при 4 байтах) или от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807 (при 8 байтах))

long long - целочисленная переменная, которая занимает 8 байт памяти (предел значений от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807)

К каждому типу данных можно добавить unsigned при создании переменных и тогда у переменной не будет отрицательных значений, но максимальное положительное значение поднимается практически в два раза

##### Числа с плавающей точкой
Число с плавающей точкой - это  десятичные дроби. Для записи таких чисел используется один из трёх типов данных:

float - вещественное число с одинарной плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)

double - представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)

long double - представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.

Символьные типы:

- char: представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255
- wchar_t: представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)
- char8_t: представляет один символ в кодировке Unicode. Занимает в памяти 1 байт. Может хранить любой значение из диапазона от 0 до 256
- char16_t: представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535
- сhar32_t: представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295

Это всё - базовые типы данных в C++. Изучив эти типы данных, уже можно хранить в программе какие-либо данные (целые числа, буквы или даже дроби)

Давайте разберёмся, как создать перменную в C++:
Допустим, нам нужна переменная, которая будет хранить возраст студента Пети:
```cpp
#include <iostream>

int main() {
	int petyaAge = 18;
	return 0;
}
```
Как вы можете заметить, в названии переменных нет пробелов, а слова отделяются друг от друга с помощью верхнего регистра.

Хранение символов выглядит вот так:
```cpp
#include <iostream>

int main() {
	char symb = 'x';
	return 0;
}
```

Допустим, мы хотим создать переменную, которая будет хранить число пи:
```cpp
#include <iostream>

int main() {
	double PI = 3.141592654;
	return 0;
}
```
Готово!
Теперь у вас может возникнуть вопрос, почему переменная PI обозначена большими буквами. Более подробно об этом будет в следующих главах. 
##### Константы
Константа - неизменяемое выражение
```cpp
#include <iostream>

int main() {
	const double PI = 3.141592654;
	return 0;
}
```
Так как число пи  в математике - всегда одно число, его нужно записать, как константу - неизменяемое значение.
### Глава 3.  Математические операции
В предыдущей главе мы разобрались, как создавать переменные и поняли, что можно хранить данные в программе. Теперь разберёмся, что можно делать с этими данными.
В курсе школьной информатики вы познакомились с большинством операций, которые можно выполнять над числами, независимо от того, какой язык программирования вы там учили.
В современных языках программирования есть три вида математических операторов:
1. Унарные (один операнд)
2. Бинарные (два операнд)
3. Тернарные (три операнда)

Разберёмся с каждым типом операций:
##### Унарные операции
Как можно производить вычисления с одним операндом? Да очень просто!
Всего есть две операции:
Инкремент (x++) - увеличение значения переменной на 1
Декремент (x--) - уменьшение значения переменной на 1

Давайте взяглянем на это в коде:
```cpp
#include <iostream>

int main() {
	int x = 5;
	x++; // Теперь x равен уже 6
	x--; // Теперь x снова равен 5
	return 0;
}
```

Важный момент. Инкремент, как и декремент, может быть постфиксный (x++), а может быть префиксный (++x), форма записи не изменяет принцип работы оператора.
Разница префиксных и постфиксных инкрементов:
Постфиксный - имеет малый приоритет
Префиксный  - имеет большой приоритет

##### Бинарные операции
Бинарные операции - стандартные операции, мы привыкли к ним на информатике в школе и на математике:
Арифметика:
"+" - сложение
"-" - вычитание
"\*" - умножение
"/" - деление (так как мы уже прошли типы данных, стоит пояснить, что для целочисленных переменных - деление целочисленное, для числе с плавающей точкой - можно получить десятичную дробь)
"%" - остаток от деления
Сравнение:
">" - больше (результат - bool)
"<" - меньше (результат - bool)
">=" - больше либо равно (результат - bool)
"<=" - меньше либо равно (результат - bool)
"=" - оператор присваивания (задаём значение переменной)
"\==" - оператор сравнения (сравниваем значение двух переменных) (результат - bool)
"!" - отрицание (превращает true в false)

Приоритет операций такой же, как и в математике
В этой главе мы лишь немного затрагиваем логику, в следующих главах будет более подробное объяснение и больше операторов 

Это все основные бинарные операции, давайте взглянем на примеры:
```cpp
#include <iostream>

int main() {
	int x = 2;
	int y = 3;
	std::cout<< x + y << "\n"; // 5
	std::cout<< x * y << "\n"; // 6
	std::cout<< y / x << "\n"; // 1
	std::cout<< y == x << "\n"; // false
	return 0;
}
```
И так далее, принцип работы не отличается от python и pascal

##### Тернарные операторы
Эти операторы используют три операнда в работе, более подробно остановимся на них в главе про логику

### Глава 4. Логическое ветвление
Звучит страшно, не правда ли?
Но на самом деле логическое ветвление - очень простая вещь, без которой невозможно представит себе программирование. Логическое ветвление - часть программы, которая зависит от изречения, на которое можно дать ответ да или нет.
Например, если идёт дождь, то мы берём зонт. Взглянем на это в коде:
```cpp
#include <iostream>

int main() {
	bool itsRaining = true;
	if (itsRaining) {
		takeAnUmbrella();
	}
	else {
		dontTakeAnUmberella();
	}
	return 0;
}
```
Разберёмся, что здесь происходит
if - условный вопрос, в скобочках записывается выражение, на ответом на которое будет являться тип данных bool (true/false). Если результатом будет являться true, то выражение, записанное в фигурных скобках, выполнится. Если результат выражения - false, то выполнится выражение, записанное в фигурных скобках после false. 
Блок else писать необязательно.

#### Тернарный оператор
Кажется, что выражение выглядит громоздким, чтобы его сократить, обратимся к тернарному оператору.

```cpp
#include <iostream>

int main() {
	bool itsRaining = true;
	itsRaining ? takeAnUmbrella() : dontTakeAnUmbrella();
	return 0;
}
```

Выглядит менее громоздко, хотя и кажется более сложным. Разберёмся подробнее.
До вопросительного знака пишется выражение, результатом которого будет тип данных bool.
После вопросительного знака пишется действие, которое нужно выполнить, в случае, если на выражение будет получен результат true.
После двоеточия пишется действие, которое нужно выполнить в случае, если на выражение будет получен результат false.
#### Логические операторы
А теперь представим, что нам нужно, чтобы код выполнился при совпадении двух разных условий, для этого нужно использовать логические союзы:
"&&" - и - выполняются оба условия

"||" - или - выполняется хотя бы одно из условий
"^" - исключающее или - одно из условий истино, а второе - ложно
"!" - отрицание - true -> false; false -> true;
"<=" - импликация (из A следует B)
"\==" - эквиваленция - одно выражение равно другому

##### Пример
А теперь допустим, что нам нужно определить, является ли число двузначным
```cpp
#include <iostream>

int main() {
	int x = 50;
	if ((x > 9) && (x < 100)) {
		std::cout<<"X - двузначное число";
	}
	else {
		std::cout<<"X - не двузначное число";
	}
	return 0;
}
```

### Switch
А теперь представьте, что вам нужно создать несколько условий в программе. Несколько условий можно создать несколькими способами.
```cpp
#include <iostream>

int main() {
	char key_pressed;
	std::cin >> key_pressed;
	if (key_pressed == 'W') {
		move_forward();
	} else if (key_pressed == 'S') {
		move_back();
	} else if (key_pressed == 'A') {
		move_left();
	} else if (key_pressed == 'D') {
		move_right();
	} else {
		std::cout << "Cant control your player by this button"
	}
	return 0;
}
```
Итак, перемещение персонажа - один из простейших примеров организации условного оператора со множественным условием. Но можно ли сделать эту запись менее громоздкой и более удобной? Да, можно:

```cpp
#include <iostream>

int main() {
	char key_pressed;
	std::cin >> key_pressed;
	switch (key_pressed) {
		case 'W':
			move_forward();
			break;
		case 'S':
			move_back();
			break;
		case 'A':
			move_left();
			break;
		case 'D':
			move_right();
			break;
		default:
			std::cout << "Cant control your player by this button";
	}
	return 0;
}
```
Разберёмся, что тут проиходит:
switch (<переменная>) - создание оператора ветвления.
case - описание каждого условия, при котором выполняются конкретные действия.
default - используется, когда ни одно из условий не является истинным.
### Глава 5. Циклы
Цикл - программа, которая выполняет похожие действия несколько раз

Допустим, мы хотим посчитать факториал для какого-либо числа, самая простая реализация будет выглядеть так:
```cpp
#include <iostream>

int main() {
	int n;
	std::cin>>n;
	int fact = 1;
	for (int i = 1; i < n; ++i) {
		fact = fact * i;
	}
	return 0;
}
```

Строка с for выглядит сложно, не так ли?
Давайте разбираться.
int i = 1 - мы создали переменную, которая будет хранить значение с текущим элементом факториала.
i < n - условие, до доситжения которого цикл будет выполняться (результатом должен являться bool)
++i - инкремент (помните, что это? Если нет, то посмотрите главу 3. Математические операции)

Но for - не единственный цикл в C++. Рассмотрим другой пример:
```cpp
#include <iostream>

int main() {
	int x = 0;
	while (x < 5) {
		std::cout<< ++x;
	}
	return 0;
}
```
Цикл будет выводить значения от 1 до 5 включительно
Разберём более подробно
while - пока, в круглых скобочках указывается выражение, результатом выполнения которого будет являться bool-выражение

На этом завершается изучение основ языка C++. Основы языка знаем, теперь к самому интересному. Погнали!
### Глава 6. Ссылочные типы данных
До этого мы познакомились с простейшими типами данных, такими, как int, float, double, char и подобные. Но для полноценно работающей программы этого мало, нужны ссылочные типы данных.
##### Что такое этот ссылочный тип?
Чтобы перейти к ссылочным типам данных, нужно разобраться, как хранятся данные в программе. Вроде бы всё просто - есть переменная и там хранится значение. Но переменные делятся не только по типу данных, но и по тому, где они хранятся.
В памяти переменные хранятся в двух структурах: стэк и куча.
###### Что такое стэк?
Стэк - область памяти, предназначенная для хранения простейших переменных (int, bool, char и т.д.). Доступ к данным в стэке - очень быстрый, но объём данных в стэке ограничен
###### Что такое куча?
Куча (полное название - управляемая куча) - большая область памяти, которую программа использует для хранения больших данных. Чтобы получить доступ к этим данным, компьютер обращается по ссылке к конкретной ячейке этой области, отсюда и название данных, хранящихся здесь - ссылочный тип.

##### Какие типы - ссылочные?
Ссылочным типом называют массивы, списки, строки, множества, объекты класса (о них чуть позже).
Остановимся на каждом типе подробнее

##### Коллекции
Коллекции - ряды элементов одного типа, объединенных в общую структуру
###### Массив (array)
Массив - коллекция элементов одного типа с фиксированной длиной (звучит страшно, не так ли?)
```cpp
#include <iostream>

int main() {
	std::array<int, 5> array1 = {1, 2, 3, 4, 5};
	return 0;
}
```
Итак, в C++ массивов не существует в чистом виде. Для использования этой структуры данных нужно обратиться к библиотеке std.
Дальше давайте разбираться. array - в переводе с английского - массив, в треугольных скобочках указывается тип данных массива и, через запятую - количество элементов, потом идёт название массива (имя переменной), потом, через равно в фигурных скобках записываются все элементы массива. (ВАЖНО! Количество элементов в массиве должно совпадать с числом, указанным в треугольных скобках)
###### Список (list)
Список - коллекция элементов одного типа (вот такое есть в Python).
```cpp
#include <iostream>

int main() {
	std::list<int> list1 = {1, 2, 3, 4, 5};
	return 0;
}
```
Для создания списка нужно обратиться к std, только в этот раз мы вызываем не array, а list и не указываем в треугольных 
###### Множество (set)
Множество - коллекция уникальных элементов одного типа (тоже есть в Python)
```cpp
#include <iostream>

int main() {
	std::set<int> set1 = {1, 2, 3, 4, 5};
	return 0;
}
```
Для создания множества нужно снова обратиться к std, потому то сами по себе C++ не содержат такого функкционала, в треугольных скобках указываем только тип данных, множество не ограничено длиной.
##### Другие ссылочные типы

###### Строка (string)
Строка - тип данных, необходимый для того, чтобы хранить какие - либо слова или предложения.
```cpp
#include <string>
#include <iostream>

int main() {
	string username;
	cin >> username;
	return 0;
}
```
Что делает эта программа? Давайте разбираться.
string - новый тип данных, для его использования нужно подключить библиотеку string. Потом программа получает на вход строку username, теперь это имя записано в программу.

На этом заканчиваются базовые ссылочные типы данных, в следующей главе разберёмся, какие операции можно производить над этими типами.

### Глава 7. Операции на коллекциями и строками.
Как вы уже знаете, данные нужно не только хранить, но и обрабатывать, базовые типы данных могут обрабатываться с помощью стандартных арифметических действий, bool - логические выражения (Математическая логика), а что можно сделать с коллекцией?

#### Массив (array)
Массив можно создать и заполнить элементами (если известные не все данные, то можно запомнить массив чем угодно, например, нулями)
Для заполнения массива можно использовать циклы, например, for или while

##### Заполнение массива
```cpp
#include <iostream>

int main() {
	std::array<int, 5> array1 = {0, 0, 0, 0, 0};
	for (int i = 0; i < 5; ++i) {
		array1[i] = 0;
	}
	return 0;
}
```
После выполнения программы, массив будет заполнен числами от 0 до 4

###### Вывод элементов массива
В Python вывод всех элементов массива выглядит так: 
```Python
array1 = [1, 2, 3, 4, 5]
print(array1) # или print(*array1)
```
В C++ нельзя вывести сразу всю коллекцию, поэтому вывод всей коллекции выглядит так:
```cpp
#include <iostream>

int main() {
	std::array<int, 5> array2 = {1, 2, 3, 4, 5};
	for (int i = 0; i < 5; ++i) {
		std::cout << array2[i] << "\n";
	}
	return 0;
}
```

#### Список (list)
```cpp
#include <iostream>
#include <list> // Для выполнения операций над списками импортируем библиотеку list

int main() {
	std::list<int> list1 = {1, 2, 3, 4, 5};
	list1.push_front(0); // Добавим 0 в начало спска
	list1.push_back(6); // Добавим 6 в конец списка
	return 0;
}
```
Существуют также и более сложные операции над списками, но с ними лучше познакомится позднее, так как нужно изучить итераторы (в C++ с ними всё не так чтобы просто, лучше на этом этапе обойтись этими операциями)
### Множество (set)
```cpp
#include <iostream>

int main() {
	std::set<int> set1 = {1, 2, 3, 4, 5};
	set1.push_front(0); // Добавим 0 в множество
	return 0;
}
```
Есть ещё операция удаления, но к ней вернёмся после итераторов.
# Глава 8. Макросы
Теперь много новой информации, которая в 90% случаев окажется бесполезной. 
В C++ есть возможность создать макросы - заменить одно выражение другим с помощью макросов можно создавать всякую ~~бесполезную фигню~~ более удобную реализацию по синтаксису, например, такая ~~бесполезная фигня~~ более удобная форма записи - язык программирования для гопников YoptaScript (можете посмотреть, если интересно)
А как такое выглядит в коде?
```cpp
#define print(x) std::cout << x
#include <iostream>

int main() {
	print("Hello, World!");
	return 0;
}
```
Например, вот так, эта программа сделает так, что print будет выглядеть, как в python (не считая точки с запятой на конце, с эти ничего не сделаешь)
Ещё можно использовать макросы для создания констант с более удобным наименованием
Например, создадим код, который вычисляет длину окружности:
```cpp
#define PI 3.14
#incude <iostram>

int main() {
	double r;
	std::cin >> r;
	double circle_len = 2 * r * PI;
	std::cout << circle_len;
	return 0;
}
```
# Глава 9. Объектно-ориентированное программирование (ООП)
Что такое Объектно-ориентированное программирование? ООП - одна и парадигм программирования (всего их три, но не будем их рассматривать, только больше запутаемся). 
###### Зачем?
ООП нужно для того, чтобы создавать в коде объекты реального мира, описывать возможности этого объекта, например, чтобы создать машину или дом.
###### Из чего состоит ООП?
ООП состоит из классов и объектов класса. Класс - некий чертёж, заготовка, по которой мы создаём объекты. Объект - переменная, являющаяся представителем класса.
###### Как мы можем создать объект в программе?
Для создания объекта необходимо создать класс, описывающий какой-либо объект. Класс может описывать объект реального мира с использованием полей - переменных, в которые мы задаём какие-нибудь данные объекта (размер, название, масса). Для исполнения функций реального объекта обратимся к методам. Метод - функция, которая находится в классе.

```cpp
#include <iostream>
#include <string>
using namespace std;

class Car {
	string name;
	int max_speed;
	int current_speed;
	// Это всё - поля класса или переменные, характеризующие объект
public: // public - модификтор видимости, доступ ко всемуц, перечисленному здесь будет у всей программы (чуть позже расскажу про видимость методов и полей класса)
	// Здесь будут собраны все методы класса. Метод - функция
	Car(string _name, int _max_speed) { // Это - конструктор класса (немного позже расскажу подробнее)
		current_speed = 0;
		name = _name;
		max_speed = _max_speed;
	}
	void accelerate {
		if (current_speed < (max_speed - 10)) {
			current_speed += 10;
			cout << "#Acceleration. Current speed is " << current_speed << " kmph";
		} else {
			cout << "Reached maximum speed";
		}
	}
	void brake {
		if (current_speed >= 10) {
			current_speed -= 10;
			cout << "#Slowing down. Current speed is"<< current_speed << " kmph";
		}
		else {
			cout << "Already stopped";
		}
	}
}
s
int main() {
	Car bmw("M5 e34", 250);
	bmw.accelerate();
	bmw.accelerate();
	bmw.brake();
	bmw.brake();
	return 0;
}
```
###### Есть же какие-нибудь правила и ограничения в создании классов?
Да, есть. У объектно-ориентированного программирования есть три главных правила - принципа ООП.
###### Принципы ООП:
1. Полиморфизм - для модификации объекта класса нужно обратиться к вспомогательному классу
2. Инкапсуляция - на объект накладываются ограничения по функционалу, который он может выполнять (класс выполняет только заложенные в него функции)
3. Наследование - объекты дочернего класса могут использовать методы родительского класса.
4. Абстракция - выделение общих характеристик объектов, их свойств и методов, при игнорировании деталей реализации (Капец, я согласен)
###### Вырванные из контекста, принципы ООП звучат очень сложно. Давайте разберём эти принципы на примерах:
1. Полиморфизм. Допустим, что есть основной объект, например, машина. Для того, чтобы заменить колесо в машине - нужно обратиться к механику (в этом примере машина - основной класс, а механик - вспомогательный класс)
2. Инкапсуляция. Допустим, что существует некий автомобиль, в нём нельзя застрелиться из выхлопной трубы. (Такая возможность нарушила бы функционал класса автомобиль)
3. Наследование. Допустим, что существует часовой механизм (он примерно одинаковый во всех часах), при наследовании от этого механизма мы можем создать часы любой формы и размера.
4. Абстракция. Допустим, что существует несколько разных автомобилей, например, спорткар и кроссовер. Эти автомобили выполняют одинаковые функции - перевозка пассажиров и грузов, но при этом есть специфичные задачи для каждого тип автомобилей, например, кроссовер может перевозить грузы и ездить по менее ровным дорогам, а спорткар - может быстро разогнаться и развить большую скорость.
Короче, выглядит страшно и непонятно, давайте разбираться на примерах:
