# Сложные типы данных
#### Массивы
**Минусы массива**:
   - Расположение - нужно знать размер
   - Вставка и удаление за линейное время
**Плюсы массива**:
- Произвольный доступ

При разработке программы нужно учитывать:
1. Структура данных
2. Алгоритм

# Анализ сложности алгоритма
Зачем?

Пусть есть два компьютера:
$A - 10^9$
$B - 10^7$
$c_1 \space n^2 - 2$
$c_2 \space n*logn - 50$
$T_a: \frac{2*10^{4}}{10^{9}}=2*10^{-5}$
${T_b}: \frac{2*10^2*3.5}{10^7}=7*15^{-5}$
$T_a: \frac{2*10^{12}}{10^9} = 2*10^3$
$T_b: \frac{2*10^6*20}{10^7}=4$, где b - n logn, a - $n^2$

Умножение матриц
Есть три матрицы - A (5\*100), B (100\*50), C (50\*10)
$\Sigma_{k=0}^{m_a}a[i][k] * b[k][j]$

Умножение $(A*B)*C$:
$5*100*10=5000$
$5 * 10* 50 = 2500$
7500 шагов

Умножение $A*(B*C)$:
$100*10*50=50000$
$5*100*50=25000$
$75000$

## Как оценивают сложность алгоритмов?

$O(n^2)$
$\exists n_0,  0 < c_1 < c_2 \forall \underline{>} n_0: c_1 g(n) < f(n) < c_2g(n) \Rightarrow \omega(g(n))$
$O(g(n))$

При рассмотрении анализа рассматривают три случая:
1. Наилучший
2. Наихудший
3. Средний

Сортировка вставками:
```cpp
for (int i = 1; i < n; i++) {
	int j = i;
	while (j > 0 && a[j] < a[j-1]) {
		swap(a[j], a[j-1]);
		j--;
	}
}
```
$T = (c_1 + c_2)*n - c_2 + (c_3+c_4+c_5) \Sigma^{n}_{j=1}T{j}$
В лучшем случае: $T = An - c_21 \Rightarrow O(n)$
В худшем случаем $T=An - c_2j + B*\frac{n*(n+1)}{2} \Rightarrow O(n^2)$

# Динамические структуры данных
Расположены всегда в куче

Недостатки по сравнению с массивами:
- Большая память
- Непоследовательный доступ
Преимущества:
- Вставка и удаление за константное время

### Динамические структуры:
1. Списки (1. Двусвязный (каждый элемент хранит адрес следующего и предыдущего элемента, 2. Односвязный, 3. Стэк (существуют две функции - вставка и удаление в начале списка), 4. Очередь, 5. Дэк (двусторонняя очередь) 6. Кольцевой список)
2. Деревья - (set, map)
3. Графы

